
unsorted list
all link updates are atomic
lazy deletion
  - nodes marked for deletion 
  - marking of nodes and link updates should be atomic
      - if they are two separate operations it may lead to inconsistent states of the linked list
	- concurrent threads may see different versions of the linked list
  - node states : unmarked->marked (not in the other direction)
	- this reduces the number of possible consistent states of the linked list
nodes are not deleted immediated upon unlinking (may lead to segmentation faults)
  - use memory pools and/or lazy deletion
  - a pred->curr link is true if
	- pred->next == curr
	- pred is unmarked
	- curr is marked/unmarked
  - links between marked nodes may be removed by concurrent find operations
	- used only for traversing the list by add and contains operations (atomic reads)
	- these links are not used for modifying the linked list (find/erase)

requires support for 128-bit atomic operations tuple <mark,next pointer>
memory pool/garbage collection/recycling of list nodes 
	- can lead to cycles in list traversal if pointer updates are not propagated to memory atomically
	- can introduce delay between removal and recycling of nodes

add 
  - new nodes added to the head of the list
  - unique elements 
    - check for duplicates before addition
    - the existence of an element in the list is checked (value of mark field==0) 
	- exit insertion loop if element exists
	- element may be marked for deletion between checking and exit
  - leaves list in consistent state (same state as before the operation or new state : previous state + new element at end-of-list)
	- these are the only two states visible to other threads that access the linked list concurrently
  - addition to the end of the list can lead to inconsistent states
    - can be avoided by adding to beginning of the list
  - high contention since all add to the head of the list
	- can be reduced by allowing additions to anywhere in the list

contains 
   - traverses list and check if it contains an element (match value and mark field==0)
   - exit loop if element is found
      - element may be marked for deletion between checking and exit 
   - does not alter the state of the linked list
   - leaves linked list in consistent state
   - marked nodes in the list may lead to cycles in the traversal if node is unlinked before a thread reads its next field.
	- exit loop and retry if next pointer is invalid

find 
  - traverses linked list, removes marked nodes, returns (pred,curr) pointers where both nodes are unmarked, pred->curr and the value in curr node is equal to requested key
  - link updates are performed for all nodes marked for deletion (from an unmarked predecessor node)
     - removal of nodes can only be performed from an unmarked predecessor
     - if the initiator of node removal is marked at any time during the find operation, it abandons the operation and retries till it finds an unmarked predecessor 
	- otherwise, the linked list may be left in inconsistent states
     - find terminates :
	- node found (return (pred,curr))
        - reached end-of-list (return (head,nullptr))
        - node found, marked (return (head,nullptr))
        - the node or its predecessor may be marked for deletion between find and exit

erase
     - uses find operation to locate element to the erased
     - the (pred,curr) pointers returned by find are used for marking and link updates
     - if pred or curr are marked, the operation is abandoned
       - there may be concurrent find/erase operations that may delete these nodes
       - if nodes are deleted immediately, this may lead to segmentation faults (invalid pointer accesses)
	- use garbage collection/delayed deletion/memory pools/recycling etc
     - only one erase/mark operation succeeds
     - if curr is unmarked, it is marked
     - if marking succeeds, update pred link (unlink curr)
	- fails if pred is marked concurrently or curr is erased by other find/erase operations 
     - retry upon failures until find returns (curr=nullptr), the node to erase is not found in the list 

update 
    - updates value field
    - use a bit in mark field of tuple <mark,next> to lock node for updates
    - traverses list to find node with key (mark==0,update==0)
    - lock node for updates by setting update bit = 1
    - unlock node after updates
    - erase operation will have to wait until node is unlocked (all updates are over)

functions are atomic, they do not conflict with each other :
	- concurrent executions of add/contains/find and erase are possible
	- lead to linearizable executions of all operations


Incremental resizing
    - addition of new block should be atomic
    - detect block full and set state to full atomically
    - there may be insert/find/erase in progress (started before the block became full)
    - find/erase should be allowed to complete
    - inserts which detect full state will abandon and retry in new block
    - inserts which did not detect full state 
	- should complete and should be available for future inserts in the new block (duplicate check)
	- insert in previous block should complete before find in new block
        - if full==0 before insert, add node, check full after insert, mark for deletion if state changed
